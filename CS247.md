#Overloading

#Private Implementation

**Private Implementation** (PImpl) is used to encapsulate data representation in a private structure, which can be in a separate file.

#Operators

C++ has 6 **special member functions** that have compiler-provided default versions:

* **default constructor**: provided only if we define no constructor
    * simple data members/pointers are not initialized
    * member objects/inherited members are initialized with their default constructors
* **destructor**
    * simple data members are deallocated
    * pointers are deallocated (not deleted)
    * member objects/inherited members are cleaned up using their destructor
* **copy constructor**: constructs a new object with values equal to the provided object
* **assignment**: uses the `=` operator
* **move constructor**:
* **move assignment**:

If an object is copied with a **shallow copy**, any pointers in the new object will refer to the same addresses of the original object. In a **deep copy**, the data pointed to by pointers will be copied, not the address of the data.

#Modules

##Program Decomposition

Programs are divided into multiple files called **modules** in order to separate functionality and allow new functionalities to be easily added or removed. Modules are software components that encapsulate some design decision (e.g. a class, function, library). We need to consider how different modules can access and interact with each other.

###Header Files

*Problem*: a module needs to access classes, variables, types, functions, etc. that are defined in other modules.

*Solution*: if a module makes any declarations used by other modules, they should be placed in a **header file**. All other modules that access it should `#include` the header file. The preprocessor replaces `#include` statements with the contents of th header.

Note: never place a `using namespace ...` directive in a header file, or before the `#include` directive in an implementation file.

```c++
// ADT.h
class ADT {
public:
    ADT();
};

// ADT.cpp
#include ADT.h
ADT::ADT() {
    // ...
}
```

###Header Guards

*Problem*: a header file may be included multiple times, make some compilation redundant.

*Example*: `main.cpp` includes `ADT1.cpp, ADT2.cpp`, and `ADT1.cpp` includes `ADT2.cpp`. Then `main.cpp` includes `ADT2.cpp` twice.

*Solution*: module headers should wrap all of its content with a **header guard**, which gives modules a unique name and prevents it from being compiled multiple times during preprocessing.

```c++
#ifndef ADT_H
#define ADT_H
// class declaration, functions
#endif
```

###Circular Dependency

*Problem*: two or more header files depend on (`#include`) each other.

*Solution*: a **forward declaration** notifies the compiler that something will be declared/defined later, breaking circular dependencies.

```c++
// ADT1.h
#include "ADT2.h"
class ADT2;
class ADT1 {
    friend class ADT2;
};

// ADT2.h
#include "ADT1.h"
class ADT1;
class ADT2 {
    ADT1* s;
};
```

##Separate Compilation

When rebuilding a program, only files that have changed need to be recompiled (and all files that depend on them).

* the executable file depends on `.o` **object** files
* `.o` files depend on `.cpp` files
* `.cpp` files depend on `.h` files

**Make** (`make`) is a UNIX command that builds programs using instructions and dependencies provided in a programmer-created `Makefile` file. A `Makefile` consists of a **dependency graph** that defines what object files are needed by an executable, and a **build rule** that specifies how object files are generated.

```bash
program.exe: main.o ADT1.o ADT2.o # dependency graph
    g++ main.o ADT1.o ADT2.o -o program.exe # build rule
```

#Interface Specification

An **interface** is an abstract description of a module that can be responsible for information hiding. An interface consists of a **signature** that specifies syntactic requirements, and a **specification** that describes the module's behavior.

An **interface specification** documents the expectations of the module provider and client programmer.

**Specification fields** are optionally included in an interface specification to define keywords or variables used in the interface specification.

##Conditions

**Preconditions** and **postconditions** are a set of expectations associated with a member function. All expressions are over public variables and values (not private).

Preconditions are constraints applicable immediately before a method is called:

* **requires**: necessary assumptions on the program state

Postconditions are constraints applicable immediately after a method is called, assuming its preconditions are met:

* **modifies**: objects changed by the method
* **throws**: thrown exceptions and their conditions. The preconditions do not include conditions that lead to thrown exceptions
* **ensures**: guaranteed side effects on modified objects
* **returns**: method return value

```c++
int sumVector(const vector<int>& vect);
// requires: vect is an initialized, non-empty vector
// throws: MaxIntExceeded, if sum > int capacity
// returns: integer sum of all elements in vect
```

```c++
class IntStack {
    // specification fields:
    // top = most recent element of the stack
public:
    IntStack();
        // ensures: initializes this to an empty stack
    ~IntStack();
        // modifies: this
        // ensures: this is deallocated and no longer exists
    void push(int elem);
        // modifies: this
        // ensures: this = this@pre + elem, top == elem
    void pop();
        // modifies: this
        // ensures: if this@pre is empty, this is empty
        //          else this = this@pre with top removed
    int top();
        // requires: this is not empty
        // return top
};
```

##Derived Specification

Derived classes inherit interface signatures as well as specifications. Derived classes can be specified by just listing new fields. Overridden methods provide complete specification.

#Exceptions

#RAII

#Abstraction Function

A mapping from concrete code implementation to the abstract model of an ADT. If the data looks exactly like what the user thinks, this is trivial. This is more useful for expressing abstract ADTs.

```c++
struct Card {
    char suit; // c, d, h, s
    int rank; // 1-13
};
// AF(Card)
// suit = clubs if 'c', diamonds if 'd', hearts if 'h', spades if 's'
// rank = ace if 1, jack if 11, queen if 12, king if 13, rank otherwise

struct Card{
    int id; // 0-51
};
// AF(Card)
// suit = id / 13
// rank = id % 13 + 1
```

#Representation Invariant

A boolean expression property of an ADT that is true at all times and can be used for **assertions**.

#UML

#Singleton Pattern

A **singleton** object is set up so that its constructor is private, and a static class method exists to create a single instance and get a reference to it.

```c++
class Singleton {
private:
    Singleton();
public:
};
```

#Strategy Pattern

*Problem*:

*Example*: in a card game, AI players can have different levels of difficulty.

*Solution*: the **Strategy Pattern** features multiple implementations of a function. A function can be encapsulated in an object, and overridden in child classes. The main program can use polymorphism to swap between different chile classes at runtime.

#Adapter Pattern

#Facade Pattern

*Problem*: the client needs to interact with a subsystem of multiple complex classes.

*Example*: a card game involves a number of necessary backend classes such as `Player`, `Card`, `Deck`, etc. The GUI client needs a simple way to interface with the entire game, so a `Game` class can be created that unifies and simplifies interaction.

*Solution*: create a single interface that restricts client interaction with the subsystem classes.

#Template Method

*Problem*: a class method should have a general structure, but can very slightly in functionality when called by subclasses. Redefining the entire method in the child would be redundant and difficult to maintain.

*Example*: a Turtle object draws itself by draw individual components (e.g., its shell, head, feet). Variations such as RedTurtle or GreenTurtle want to be able to redefine some aspects of drawing, but not entirely.

*Soltuion*: the **Template Method** sets up a non-virtual method with virtual components (helpers). Each subclass can 'customize' the pieces by defining concrete methods. This is used in situations where a particular method should generally behave the same, but can vary slightly among subclasses.

```c++
class Turtle {
    drawTurtle() {
        drawShell();
        drawTail();
        drawHead();
        drawFeet();
    };
    virtual drawShell() { ... }
    virtual drawTail() { ... }
    virtual drawHead() { ... }
    virtual drawFeet() { ... }
};

class RedTurtle : public Turtle {
    drawShell() { ... }
    drawHead() { ... }
};

class GreenTurtle : public Turtle {
    drawShell() { ... }
    drawFeet() { ... }
};
```

#Observer Pattern

*Problem*: a module requires information from other modules after events occur. This may involve many queries, which can be very inefficient.

*Example*: in a chat messenger, it makes more sense for the messenger to receive incoming message updates, rather than query at regular intervals for new messages.

*Solution*: using the **Observer Pattern**, the **subject** maintains a collection of subscribed **observers**, and contacts each observer when its state changes.

* the observer pattern minimizes coupling between subjects and observers
* the subject doesn't know how many or what kind of observers it has - it simply publishes notifications of changes to any observers it might have
* observers can (un)subscribe to subjects at run-time
* subject and observer classes are easy to reuse in other applications

Instead of having the subject **push** data, they simply notify observers that their state has changed and the observers can **pull** the specific data they need. The alternative design depends on the frequency of operations and the complexity of the data.

```
class Subject {
public:
	void subscribe (Observer*);
	void unsubscribe (Observer*);
protected:
	void notify();
private:
	std::set<Observer*> observers_;
};

class Observer {
public:
	virtual void update () = 0;
private:
	Subject *subject_;
};
```

#MVC

#Refactoring

#Single Responsibility Principle

#Open-Closed Principle

A model should be open for extension but closed to modification. Client code depends on an abstract class that can be extended, rather than a concrete class. Abstract classes can also define **default implementation** which declare common data and operations. This makes it easer to derive new classes.

#Liskov Substitutibility Principle

A derived class must preserve the behaviour of its base class, so that it will work with client code that uses the base class. When overriding an inherited virtual function, three criteria must be preserved:

* **method signatures**
    * same parameters
    * same return type
    * same or fewer exceptions raised
* **method behaviour**
    * maintains or weakens the precondition
    * maintains or strengthens the postcondition
* **properties**
    * preserve invariants
    * preserve memory and time requirements for performance

In the following example, a `CountStack` is a specialized `Stack` of integers that also keeps track of how many pushes have been made.

```c++
// Stack definition
class Stack {
    long* items_;
public:
    Stack();
    ~Stack();
    long top() const;
    long pop();
    virtual void push(long);
};

// CountStack definition
class CountStack : public Stack {
    int count_;
public:
    CountStack();
    void push(long);
    int numPushes() const;
};

// CountStack implementation
CountStack::CountStack() : count_(0) {}

CountStack::push(long item) {
    Stack::push(item);
    count_++;
}

CountStack::numPushes() const {
    return count_;
}
```

#Dependency Inversion Principle

#Composite Pattern

#Iterator Pattern

*Problem*: we want to iterate through elements of a collection, that may be stored in any way.

*Example*: we want to apply a function `transform()` to all elements of a collection.

*Solution*: create an **iterator** class that defines *how* to traverse a collection, and does so without exposing the collection's implementation.

#Decorator Pattern

*Problem*: an object contain many arbitrary components and functionalities in any kind of combination. Distinguishing between multiple objects using inheritance can lead to many different subclasses and unmanageable code.

*Example*: a window can contain many components, such as scrollbars, menu bars, frames, and borders. There is no practical way to represent all combinations using inheritance.

*Solution*: we use a **decorator**, which wraps other nested components. A decorator intercepts calls to its children, such as `draw()`. It can add functionality, cancel calls, add new operations, and so on.

###Properties

Decorators encapsulate features and additional responsibilities that are added or removed at runtime.

Decorators can only be used when all components operate independently.

###Implementation

Decorated objects are created by passing their components when constructing them.

```c++
// FileListing, Border, HScroll, and VScroll all extend VisualComponent
// bsList is the wrapper, and is responsible for drawing its components
VisualComponent* list = new FileListing();
VisualComponent* bList = new Border(list);
VisualComponent* bsList = new HScroll(new VScroll(bList));
...
bsList->draw();
```

#Factory Pattern

#Generic Containers

##STL

The **Standard Template Library** (STL) is a major component of the C++ standard library that includes a collection of generic and general-purpose classes and functions, such as

* **Containers**
    * take an element type as a parameter
    * store and retrieve objects of a certain type
    * know nothing about the element type
    * know how to compare (`<` and related operators) elements if **ordered**, or by using functors
    * define their own iterators
* **Algorithms**
    * know almost nothing about data structures and their elements
    * operate on elements using iterators
    * almost any algorithm works with almost any container

STL avoids inheritance by design. It uses templates to provide flexible, 'ad hoc' polymorphism. Containers are different enough to not warrant code reuse, and don't have virtual methods to improve efficiency.

##Polymorphic Containers

Containers of objects have more expensive copy operations, but containers of pointers require the client code to cleanup pointer references.

```c++
// object example
Circle c("red");
vector<Figure> figList;
figList.push_back(c);

// pointer example
Circle c("red");
vector<Figure*> figList;
figList.push_back(&c);
```

The C++98/03 standard provides a number of useful, general-purpose containers:

|STL container|Type|Operators|
|-|-|-|
|all||`size` `empty` `insert` `erase`|
|`vector<T>`|sequence|`[]` `at` `back` `push_back` `pop_back`|
|`deque<T>`|sequence|`[]` `at` `back` `push_back` `pop_back` `front` `push_front` `pop_front`|
|`list<T>`|sequence|`[]` `at` `back` `push_back` `pop_back` `front` `push_front` `pop_front` `sort` `merge` `reverse` `splice`|
|`set<T>` `multiset<T>`|ordered associative|`find`|
|`map<T1,T2>` `multimap<T1,T2>`|ordered associative|`[]` `at` `find` `count`|
|`stack`|adapter|-|
|`queue`|adapter|-|
|`priority_queue`|adapter|-|
|`bitset`|-|-|

##Sequence Containers

A **sequence container** such as a vector or list stores its elements contiguously (no gaps) in an order determined by their insertion order.

###Vector

A **vector** is conceptually similar to an array with expandable bounds. Vectors have constant time element access using `[]`, `at()` and also support operations such as appending/prepending elements. Vectors have a hidden capacity and are reallocated once the capacity is exceeded.

Vectors can be practically implemented using an array, supporting pointer arithmetic, although prepending or deleting elements are $O(n)$ operations.

###Deque

**Deques** (double-ended queues) are similar to vectors. There is no guarantee that elements are stored contiguously, but deques can prepend elements in constant time.

A deque can be implemented using a circular buffer (vector, dynamic array) of pointers to fixed-sized chunks of elements (array). Reallocation with a deque is faster than a vector.

###List

A (doubly-linked) **list** is designed for fast insertion and deletion to the front and back. However, random access is an $O(n)$ operation (unsupported API).

##Container Adapters

#Generic Algorithms

In most cases, an **STL algorithm** processes a sequence of data elements bounded by two iterators, and operates on every element in between during traversal. An algorithm is **non-modifying** if it reads but never writes to elements.

```c++
template<class InputIterator, class T>
InputIterator find(InputIterator first, InputIterator last, const T& val);
```

**Duck typing** is a realization of polymorphism through type parameters. A class `C` object is **type-compatible** with a template parameter type `T` if it supplies all methods and method signatures used in the template. C++ STL (templates, algorithms) rely on duck typing.

>If it walks like a duck, and talks like a duck, it must be a duck.

###Iterator Type Hierarchy

'Fancier' iterators are a superset of iterator functionality. Duck typing applies: any STL algorithm that requires an `InputIterator` as a parameter also accepts a fancier iterator according to this hierarchy:

1. input/output iterators `istream` `ostream`
1. forward iterators `unordered_set` `unordered_multiset` `unordered_map` `unordered_multimap`
1. bidirectional iterators `list` `set` `multiset` `map` `multimap`
1. random access iterator `vector` `deque`

#Lambda Functions

#Templates

*Problem*: overloaded functions can have identical bodies, and only differ by their argument types. This means duplicate code.

*Example*:

```c++
int compare(const int &v1, const int &v2) {
    if (v1 < v2) return -1;
    if (v2 < v1) return 1;
    return 0;
}

int compare(const string &v1, const string &v2) {
    if (v1 < v2) return -1;
    if (v2 < v1) return 1;
    return 0;
}
```

*Solution*: a **function template** can be used to describe a family of functions. The client programmer uses a template, and the compiler generates type-specific versions. If the function has multiple arguments, the types must all match. Templates rely on Duck Typing.

```c++
template <typename T>
int compare(const T &v1, const T &v2) {
    if (v1 < v2) return -1;
    if (v2 < v1) return 1;
    return 0;
}

compare(1, 3); // compare<int>
compare(3.14, 2.7); // compare<double>
compare(1, 3.14); // error - type cannot be inferred
```

###Class Template Instantiation

Templates can also used to define generic, parameterized classes. The template parameter type must be provided by the programmer - the compiler cannot infer the type.

```c++
template <typename T>
class Stack {
public:
    Stack();
    T top();
    ...
private:
    T items_[256];
    int top_;
    ...  
};

Stack<string> stringStack;
Stack<int> intStack;
Stack<Figure*> figureStack;
```

###Non-Type Template Parameters

Templates can also have **template parameters**, treated like compile-time constants. Client code provides compile-time values, or the template parameter can specify a default value.

```c++
template <typename T, int size = 256>
class Stack {
public:
    Stack();
    T top();
    ...
private:
    T items_[size];
    int top_;
    ...  
};

Stack<int, 100> intStack1; // size 100 stack
Stack<int> intStack1; // size 256 stack
```

In a class template, three kinds of friend declarations may appear:

* friend declaration for an ordinary nontemplate class/function
* friend declaration for a template class/funtion: grants access to all instances of the friend
* friend declaration for a specific instance of a template class/function

##Template Instantiation

1. First, the template definition is compiled. If the code *might* be legal for some `T`, then the definition is legal and will succeed in compiling.
1. Wherever a template is instantiated, the class/function is type checked again.
1. The template prefix `template <class T>` needs to be added to template classes and functions in the header file.
